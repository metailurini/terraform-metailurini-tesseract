#!/usr/bin/env bash

set -euo pipefail

script_path=$(realpath "${BASH_SOURCE[0]}")
script_dir=$(dirname "$script_path")

attr_list=()

name_default=""
name_description="Name of the service"
name_type="string"
name_service_type="$name_type"
attr_list+=("name")

restart_default='"on-failure"'
restart_description="Restart policy"
restart_type="string"
restart_service_type="$restart_type"
attr_list+=("restart")

environment_default="{}"
environment_description="Environment variables"
environment_type="map(string)"
environment_service_type="list(string)"
attr_list+=("environment")

networks_default="[]"
networks_description="Networks to connect to"
networks_type="list(string)"
networks_service_type="$networks_type"
attr_list+=("networks")

command_default='[]'
command_description="Command to run"
command_type="list(string)"
command_service_type="$command_type"
attr_list+=("command")

stop_grace_period_default='"10s"'
stop_grace_period_description="Stop grace period"
stop_grace_period_type="string"
stop_grace_period_service_type="$stop_grace_period_type"
attr_list+=("stop_grace_period")

entrypoint_default="[]"
entrypoint_description="Entrypoint to run"
entrypoint_type="list(string)"
entrypoint_service_type="optional($entrypoint_type)"
attr_list+=("entrypoint")

working_dir_default='""'
working_dir_description="Working directory"
working_dir_type="string"
working_dir_service_type="optional($working_dir_type)"
attr_list+=("working_dir")

healthcheck_default='{}'
healthcheck_description="Healthcheck"
healthcheck_type="map(string)"
healthcheck_service_type="optional($healthcheck_type)"
attr_list+=("healthcheck")

ports_default="[]"
ports_description="Ports to expose"
ports_type="list(object({ host_port = number, container_port = number }))"
ports_service_type="list(string)"
attr_list+=("ports")

volumes_default="[]"
volumes_description="Volumes to mount"
volumes_type="list(object({ mount_name = optional(string), container_path = string, abs_host_path = optional(string) }))"
volumes_service_type="$volumes_type"
attr_list+=("volumes")

configs_default='[]'
configs_description="The configs to use for the container"
configs_type="list(object({ config_file = string, destination = string, args = optional(map(string)) }))"
configs_service_type="list(object({ config_file = string, destination = string, content = optional(string) }))"
attr_list+=("configs")

directories=$(
  find "$(dirname "$script_dir")" -d 1 \
    | grep -v "$script_dir"
)

for dir in $directories; do
  # Generate the outputs for the app module
  cat <<TEMPLATE > "$dir/outputs.tf"
# Generated by ${BASH_SOURCE[0]}; DO NOT EDIT.
# Make changes to the template in ${BASH_SOURCE[0]}

locals {
  data = merge(
    {
      command : local.command
      image : local.image,
      name : local.name,
      networks : local.networks
      restart : local.restart
      stop_grace_period : local.stop_grace_period
      volumes : local.volumes
      working_dir : local.working_dir
      configs : local.configs
      ports : [
        for port in local.ports :
        "\${port.host_port}:\${port.container_port}"
      ],
      environment : [
        for env_key, env_value in local.environment :
        "\${env_key}=\${env_value}"
      ]
    },
    length(local.entrypoint) > 0 ? { entrypoint : local.entrypoint } : {},
    local.healthcheck != {} ? { healthcheck : local.healthcheck } : {},
  )
}

output "data" {
  value = local.data
}

$(
  for attr in "${attr_list[@]}"; do
    cat <<EOF
output "$attr" {
  value = local.$attr
}

EOF
  done
)
TEMPLATE
  terraform fmt "$dir/outputs.tf"

  tmp_variables=$(mktemp)
  # Generate the variables for the app module
  cat <<TEMPLATE > "$tmp_variables"
# Generated by ${BASH_SOURCE[0]}; DO NOT EDIT.
# Make changes to the template in ${BASH_SOURCE[0]}

$(
  for attr in "${attr_list[@]}"; do
    attr_type="${attr}_type"
    attr_default="${attr}_default"
    attr_description="${attr}_description"
    cat <<EOF
variable "$attr" {
  type        = ${!attr_type}
  default     = ${!attr_default}
  description = "${!attr_description}"
}

EOF
  done
)
TEMPLATE
  grep -v '^ .*default *= *$' < "$tmp_variables" > "$dir/variables.tf"
  rm "$tmp_variables"

  terraform fmt "$dir/variables.tf"
done

# Generate the variables for the builder module
cat <<TEMPLATE > "$script_dir/variables.tf"
# Generated by ${BASH_SOURCE[0]}; DO NOT EDIT.
# Make changes to the template in ${BASH_SOURCE[0]}

variable "cluster" {
  type = object({
    path          = string
    cmd_start     = string
    cmd_update    = string
    cmd_stop      = string
    cmd_deploy_fn = string
  })
}

variable "services" {
  type = list(object({
    image   = string
    $(
      for attr in "${attr_list[@]}"; do
        attr_type="${attr}_service_type"
        echo "    $attr = ${!attr_type}"
      done
    )
  }))

  validation {
    condition     = length(var.services) > 0
    error_message = "At least one service must be defined"
  }

  validation {
    condition = (
      length([for s in var.services : s.name if length(s.name) > 0]) ==
      length(var.services)
    )
    error_message = "All services must have a name"
  }

  validation {
    condition = (
      length([for s in var.services : s.name if length(s.name) > 0]) ==
      length(toset([for s in var.services : s.name if length(s.name) > 0]))
    )
    error_message = "All services must have a unique name"
  }
}
TEMPLATE
terraform fmt "$script_dir/variables.tf"

