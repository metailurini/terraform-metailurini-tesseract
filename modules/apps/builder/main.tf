terraform {
  required_providers {
    shell = { source = "scottwinkler/shell", version = "1.7.10" }
    local = { source = "hashicorp/local", version = "2.4.1" }
  }
}

variable "namespace" {
  type    = string
  default = "default"
}

locals {
  namespace_path       = "${var.cluster.path}/${var.namespace}"
  namespace_cmd_create = "docker compose up -d --remove-orphans"
  namespace_cmd_update = "docker restart $(docker compose ps -qa)"
  namespace_cmd_delete = "docker compose down"


  docker_compose_version = "3.8"
  docker_compose_config  = "${local.namespace_path}/__configs"
  docker_compose_path    = "${local.namespace_path}/docker-compose.yml"
  docker_compose_networks = distinct(flatten([
    for _, service in var.services :
    [for network in service.networks : network]
  ]))
  docker_compose_content = yamlencode({
    version = local.docker_compose_version
    networks = {
      for network in local.docker_compose_networks :
      network => {}
    }
    services = {
      for _, service in var.services :
      service.name => merge({
        for attr, value in service :
        attr => value if(
          attr != "name" &&    # We don't want to include the name in the service definition
          attr != "volumes" && # We will handle volumes separately
          attr != "configs" && # We will handle configs separately
          value != null        # We don't want to include null values
        )
        }, {
        volumes : concat([
          for volume in service.volumes :
          (
            volume.abs_host_path != null ?
            "${volume.abs_host_path}:${volume.container_path}" :
            "${local.namespace_path}/${volume.mount_name}:${volume.container_path}"
          )
          ], [
          for config in service.configs :
          "${local.docker_compose_config}/${service.name}/${config.config_file}:${config.destination}"
        ])
      })
    }
  })

  container_configs = flatten([
    for _, service in var.services : [
      for config in service.configs :
      {
        service_config_path = "${local.docker_compose_config}/${service.name}/${config.config_file}"
        content             = config.content
      }
    ] if service.configs != null
  ])
}

resource "local_file" "container_configs" {
  count    = length(local.container_configs)
  filename = element(local.container_configs, count.index).service_config_path
  content = (
    fileexists(element(local.container_configs, count.index).service_config_path) ?
    file(element(local.container_configs, count.index).service_config_path) :
    element(local.container_configs, count.index).content
  )
}

resource "local_file" "namespace_docker_compose" {
  filename = local.docker_compose_path
  content  = <<-EOT
    # Generated by "${path.module}" module; DO NOT EDIT.
    # Make changes to the template in "${path.module}" module

    ${local.docker_compose_content}
  EOT
}

resource "shell_script" "cluster_mgmt" {
  depends_on = [local_file.namespace_docker_compose]

  working_directory = var.cluster.path
  lifecycle_commands {
    create = var.cluster.cmd_start
    update = var.cluster.cmd_update
    delete = var.cluster.cmd_stop
  }
}

resource "shell_script" "namespace_mgmt" {
  depends_on = [shell_script.cluster_mgmt]

  lifecycle_commands {
    create = "${var.cluster.cmd_deploy_fn} 'cd ${var.namespace}; ${local.namespace_cmd_create}'"
    update = "${var.cluster.cmd_deploy_fn} 'cd ${var.namespace}; ${local.namespace_cmd_update}'"
    delete = "${var.cluster.cmd_deploy_fn} 'cd ${var.namespace}; ${local.namespace_cmd_delete}'"
  }
  triggers = {
    when_value_changed = local_file.namespace_docker_compose.content_md5
  }
}

